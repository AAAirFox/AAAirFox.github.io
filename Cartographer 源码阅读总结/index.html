<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>cartographer源码阅读总结 | AAAirFox</title><meta name="author" content="Zhang"><meta name="copyright" content="Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="Cartographer 源码阅读总结Cartographer 的仓库代码分 _ros 和核心两个部分。前者主要负责 ROS 主题等的发布接收，具体硬件数据的获取和转换，以供具体代码逻辑使用；后者即为 Cartographer 算法的核心。 Cartographer总体上可以看作是由局部地图更新和全局回环检测两个部分构成。在局部地图更新过程中，通过最优位姿估计，把激光扫描数据插入到当前维护的子图(">
<meta property="og:type" content="article">
<meta property="og:title" content="cartographer源码阅读总结">
<meta property="og:url" content="https://aaairfox.github.io/Cartographer%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="AAAirFox">
<meta property="og:description" content="Cartographer 源码阅读总结Cartographer 的仓库代码分 _ros 和核心两个部分。前者主要负责 ROS 主题等的发布接收，具体硬件数据的获取和转换，以供具体代码逻辑使用；后者即为 Cartographer 算法的核心。 Cartographer总体上可以看作是由局部地图更新和全局回环检测两个部分构成。在局部地图更新过程中，通过最优位姿估计，把激光扫描数据插入到当前维护的子图(">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aaairfox.github.io/self/img/cover/carto.jpg">
<meta property="article:published_time" content="2020-08-25T09:24:55.000Z">
<meta property="article:modified_time" content="2024-04-06T14:54:57.516Z">
<meta property="article:author" content="Zhang">
<meta property="article:tag" content="SLAM">
<meta property="article:tag" content="cartographer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aaairfox.github.io/self/img/cover/carto.jpg"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://aaairfox.github.io/Cartographer%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'cartographer源码阅读总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-06 22:54:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.1.1"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tags"></i><span> 标签</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/%E7%AE%97%E6%B3%95/"><span> 算法</span></a></li><li><a class="site-page child" href="/tags/Cuda/"><span> CUDA</span></a></li><li><a class="site-page child" href="/tags/C/"><span> C++</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%85%AB%E8%82%A1/"><span> 八股</span></a></li><li><a class="site-page child" href="/categories/Ubuntu%E6%93%8D%E4%BD%9C/"><span> Ubuntu</span></a></li><li><a class="site-page child" href="/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"><span> 机器人</span></a></li><li><a class="site-page child" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span> 博客搭建</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="AAAirFox"><img class="site-icon" src="/img/favicon.ico"/><span class="site-name">AAAirFox</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-tags"></i><span> 标签</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/%E7%AE%97%E6%B3%95/"><span> 算法</span></a></li><li><a class="site-page child" href="/tags/Cuda/"><span> CUDA</span></a></li><li><a class="site-page child" href="/tags/C/"><span> C++</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%85%AB%E8%82%A1/"><span> 八股</span></a></li><li><a class="site-page child" href="/categories/Ubuntu%E6%93%8D%E4%BD%9C/"><span> Ubuntu</span></a></li><li><a class="site-page child" href="/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/"><span> 机器人</span></a></li><li><a class="site-page child" href="/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"><span> 博客搭建</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">cartographer源码阅读总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2020-08-25T09:24:55.000Z" title="发表于 2020-08-25 17:24:55">2020-08-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%BA%E5%99%A8%E4%BA%BA/">机器人</a></span></div><div class="meta-secondline"></div></div></div><article class="post-content" id="article-container"><h1 id="Cartographer-源码阅读总结"><a href="#Cartographer-源码阅读总结" class="headerlink" title="Cartographer 源码阅读总结"></a>Cartographer 源码阅读总结</h1><p>Cartographer 的仓库代码分 _ros 和核心两个部分。前者主要负责 ROS 主题等的发布接收，具体硬件数据的获取和转换，以供具体代码逻辑使用；后者即为 Cartographer 算法的核心。</p>
<p>Cartographer总体上可以看作是由局部地图更新和全局回环检测两个部分构成。在局部地图更新过程中，通过最优位姿估计，把激光扫描数据插入到当前维护的子图(submap)中。由于局部地图只使用最近一段时间的传感器数据，所以存在累积误差的问题。这一问题通过全局的闭环检测来加以修正，这还是一个优化问题，Cartographer通过分支定界的方式提高了算法的运行效率。</p>
<h4 id="入口：cartographer-node"><a href="#入口：cartographer-node" class="headerlink" title="入口：cartographer_node"></a>入口：cartographer_node</h4><p>文件在 <code>cartographer_ros/cartographer_ros/node_main.cc</code> 内</p>
<p>初始化 <code>cartographer_node</code> 节点，并加载配置以建图，调用各种外部参数，最终结束后也负责收尾。</p>
<h4 id="ROS-主题的订阅，入口的核心：node"><a href="#ROS-主题的订阅，入口的核心：node" class="headerlink" title="ROS 主题的订阅，入口的核心：node"></a>ROS 主题的订阅，入口的核心：node</h4><p>负责完成 ROS 主题的<strong>订阅与发布</strong>提供服务。</p>
<p>文件在 <code>cartographer_ros/cartographer_ros/node.cc</code> 内</p>
<p>构造函数 发布注册如下主题</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>默认名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>kSubmapListTopic</td>
<td>&#x2F;submap_list</td>
<td>构建好的子图列表。</td>
</tr>
<tr>
<td>kTrajectoryNodeListTopic</td>
<td>&#x2F;trajectory_node_list</td>
<td>跟踪轨迹路径点列表。</td>
</tr>
<tr>
<td>kLandmarkPosesListTopic</td>
<td>&#x2F;landmark_poses_list</td>
<td>路标点位姿列表。</td>
</tr>
<tr>
<td>kConstraintListTopic</td>
<td>&#x2F;constraint_list</td>
<td>优化约束。</td>
</tr>
<tr>
<td>kScanMatchedPointCloudTopic</td>
<td>&#x2F;scan_matched_points2</td>
<td>匹配的2D点云数据。</td>
</tr>
</tbody></table>
<p><code>StartTrajectoryWithDefaultTopics</code> 开始轨迹跟踪（调用下面的函数）</p>
<p><code>AddTrajectory</code> 具体的轨迹跟踪，<em>通过 map_builder_bridge_ 向 Cartographer 添加一条新的轨迹</em>，之后添加用于位姿插值(PoseExtrapolator)和传感器采样(TrajectorySensorSamplers)的对象，最后订阅数据源（来做到依据数据源的不断更新来推动算法）。</p>
<p><code>LaunchSubscribers</code> 配置订阅数据源，<a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=cartographer_node%E7%9A%84%E5%A4%96%E5%A2%99_node%E5%AF%B9%E8%B1%A1">ref</a></p>
<p>具体的数据到核心算法之间的互相交换都是通过 <em>map_builder_bridge_</em> 来转换的</p>
<h4 id="数据的转换：map-builder-bridge"><a href="#数据的转换：map-builder-bridge" class="headerlink" title="数据的转换：map_builder_bridge_"></a>数据的转换：map_builder_bridge_</h4><p>文件在 <code>cartographer_ros/cartographer_ros/map_builder_bridge.cc</code> 内，map_builder 是 Cartographer 的地图构建器。</p>
<p>map_builder_bridge_ 在上面的 node 是充当一个对象的存在。由于上面的 node 会在 <code>AddTrajectory</code> 中调用 map_builder_bridge_ 相关函数，所以在此时，本 bridge 才构建。</p>
<p>AddTrajectory，即是上面 node 调用的那个同名函数里面具体的再调用。它通知 map_builder 对象添加一个轨迹跟踪器，也注册了一个回调函数 OnLocalSlamResult，用于响应 map_builder_ 完成一个局部 SLAM 或者说是成功构建了一个子图的事件。之后再构造 SensorBridge，来将 ROS 信息转为核心算法里的传感器数据类型。</p>
<p>OnLocalSlamResult，用于回调记录轨迹状态</p>
<h4 id="将-ROS-信息转换为核心算法传感器数据：SensorBridge"><a href="#将-ROS-信息转换为核心算法传感器数据：SensorBridge" class="headerlink" title="将 ROS 信息转换为核心算法传感器数据：SensorBridge"></a>将 ROS 信息转换为核心算法传感器数据：SensorBridge</h4><p>map_builder_bridge_ 中，每一条<strong>轨迹（一条轨迹可以理解为由若干个节点串联起来的一个数据结构）</strong>都会有一个 SensorBridge 对象。即这个对象负责标题的工作。</p>
<h4 id="地图：map-builder"><a href="#地图：map-builder" class="headerlink" title="地图：map_builder"></a>地图：map_builder</h4><p>到这里就已经是算法的核心部分了。在 cartographer_node 里面，构建了一个建图器 map_builder。而这个算法的不断建图的过程，就是不断通过 map_builder 的“完善”。</p>
<p>map_builder 用对象 pose_graph_ 在后台完成闭环检测和全局的地图优化(Global SLAM)，并用trajectory_builders_ 在前台跟踪运动轨迹完成局部的子图构建(Local SLAM)。</p>
<ul>
<li><strong>options_</strong>: 用于记录运行配置，它使用了google的protobuf来处理结构化的数据。    这些配置项是由cartographer_ros在系统运行之初从配置文件中加载的。</li>
<li><strong>thread_pool_</strong>: 线程数量固定的线程池。</li>
<li><strong>pose_graph_</strong>: <strong>该对象用于在后台完成闭环检测，进行全局的地图优化。</strong></li>
<li><strong>sensor_collator</strong>: 应该是用来管理和收集传感器数据的。</li>
<li><strong>trajectory_builders_</strong>: <strong>用于在前台构建子图。在系统运行的过程中，可能有不止一条轨迹，针对每一条轨迹Cartographer都建立了一个轨迹跟踪器。</strong></li>
<li><strong>all_trajectory_builder_options_</strong>: 记录了所有轨迹跟踪器的配置。</li>
</ul>
<p>在构造函数中，除了基本的配置和线程池，我们也构建了 <strong>pose_graph_</strong></p>
<h4 id="map-builder-的接口实现"><a href="#map-builder-的接口实现" class="headerlink" title="map_builder 的接口实现"></a>map_builder 的接口实现</h4><p>map_builder 继承自接口类 MapBuilderInterface</p>
<table>
<thead>
<tr>
<th>接口函数</th>
<th>接口功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>AddTrajectoryBuilder</strong></td>
<td>创建一个新的轨迹跟踪器并返回该跟踪器的索引。</td>
</tr>
<tr>
<td>AddTrajectoryForDeserialization</td>
<td>也是一个用于新建轨迹跟踪器的接口。</td>
</tr>
<tr>
<td>GetTrajectoryBuilder</td>
<td>获取一个索引为trajectory_id的轨迹跟踪器对象。</td>
</tr>
<tr>
<td><strong>FinishTrajectory</strong></td>
<td>关闭trajectory_id对应的轨迹跟踪器。</td>
</tr>
<tr>
<td>SubmapToProto</td>
<td>将submap_id所对应的子图信息填充到proto流中。</td>
</tr>
<tr>
<td>SerializeState</td>
<td>将系统状态转换为proto流，进行序列化。</td>
</tr>
<tr>
<td>LoadState</td>
<td>从proto流中加载系统状态。</td>
</tr>
<tr>
<td>num_trajectory_builders</td>
<td>获取当前轨迹跟踪器的数量。</td>
</tr>
<tr>
<td>pose_graph</td>
<td>获取用于实现闭环检测的PoseGraph对象。</td>
</tr>
<tr>
<td>GetAllTrajectoryBuilderOptions</td>
<td>获取所有的轨迹跟踪器的配置。</td>
</tr>
</tbody></table>
<p>AddTrajectoryBuilder 的核心在于 LocalTrajectoryBuilder2D 对象，这也是 local SLAM  的核心，它不是具体的轨迹跟踪器，但是是它的核心，完成了一个局部SLAM的所有功能，包括位姿估计、扫描匹配等，<strong>除了</strong>闭环检测（下文会分析）。这个函数也创建了一个 CollatedTrajectoryBuilder 对象，其继承于接口 TrajectoryBuilderInterface ，为轨迹跟踪器。</p>
<h4 id="前端核心：LocalTrajectoryBuilder2D"><a href="#前端核心：LocalTrajectoryBuilder2D" class="headerlink" title="前端核心：LocalTrajectoryBuilder2D"></a>前端核心：LocalTrajectoryBuilder2D</h4><table>
<thead>
<tr>
<th>对象名称</th>
<th>对象类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>options_</td>
<td>LocalTrajectoryBuilderOptions2D</td>
<td>轨迹跟踪器的配置选项</td>
</tr>
<tr>
<td>active_submaps_</td>
<td>ActiveSubmaps2D</td>
<td>当前正在维护的子图</td>
</tr>
<tr>
<td>motion_filter_</td>
<td>MotionFilter</td>
<td>运动滤波器，对位姿相关的数据进行降采样</td>
</tr>
<tr>
<td>real_time_correlative_scan_matcher_</td>
<td>RealTimeCorrelativeScanMatcher2D</td>
<td>实时相关性分析的扫描匹配器，算法”Real-Time Correlative Scan Matching”的实现</td>
</tr>
<tr>
<td>ceres_scan_matcher_</td>
<td>CeresScanMatcher2D</td>
<td>使用Ceres库将扫描数据放置到地图中的扫描匹配器</td>
</tr>
<tr>
<td>extrapolator_</td>
<td>PoseExtrapolator</td>
<td>位姿估计器，用一段时间内的位姿数据估计线速度和角速度，进而预测运动</td>
</tr>
<tr>
<td>num_accumulated_</td>
<td>int</td>
<td>累积数据的数量</td>
</tr>
<tr>
<td>accumulated_range_data_</td>
<td>RangeData</td>
<td>累积的扫描数据</td>
</tr>
<tr>
<td>accumulation_started_</td>
<td>std::chrono::steady_clock::time_point</td>
<td>开始累积数据的时间，也是开始跟踪轨迹的时间</td>
</tr>
<tr>
<td>range_data_collator_</td>
<td>RangeDataCollator</td>
<td>累积数据收集器</td>
</tr>
</tbody></table>
<p>有扫描匹配器(Scan Matiching)，以激光雷达的扫描数据和位姿估计为输入，使用Ceres库完成扫描匹配，输出位姿的观测值。一方面反馈给位姿估计器用于修正估计值，另一方面提供给运动滤波器(Motion Filter)用于判定机器人是否产生了运动。如果产生了运动，则将此时的点云数据插入到当前正在维护的子图中。同时输出插入的结果，包括时间、位姿、子图、扫描数据等信息。</p>
<p>此核心要接收激光器、IMU 等数据，具体对应函数为</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>AddRangeData</strong></td>
<td>激光传感器的扫描数据</td>
</tr>
<tr>
<td>AddImuData</td>
<td>IMU 数据</td>
</tr>
<tr>
<td>AddOdometryData</td>
<td>里程计数据</td>
</tr>
</tbody></table>
<h5 id="AddRangeData：基本上完成了整个Local-SLAM的业务。"><a href="#AddRangeData：基本上完成了整个Local-SLAM的业务。" class="headerlink" title="AddRangeData：基本上完成了整个Local SLAM的业务。"></a>AddRangeData：基本上完成了整个Local SLAM的业务。</h5><p>返回一个 MatchingResult 的对象，即扫描匹配后的结果，该类型中有一个字段 insertion_result ，用于描述把扫描数据插入子图的结果。    </p>
<p>具体代码则是通过循环，来处理每一个测量点的信息，根据配置（例如min_range、max_range）和实际测量情况来处理。即将原始的激光点云数据转换成占用栅格和插入器需要的 RangeData 类型的数据。</p>
<h5 id="AddAccumulatedRangeData：积累传感器数据一定量后被调用，以扫描匹配、更新子图"><a href="#AddAccumulatedRangeData：积累传感器数据一定量后被调用，以扫描匹配、更新子图" class="headerlink" title="AddAccumulatedRangeData：积累传感器数据一定量后被调用，以扫描匹配、更新子图"></a>AddAccumulatedRangeData：积累传感器数据一定量后被调用，以扫描匹配、更新子图</h5><p>先估计位姿，之后 ScanMatch 扫描匹配，再 InsertIntoSubmap 将新的扫描数据插入到子图中：调用 <strong>ScanMatch</strong> 进行扫描匹配，主要是将当前的传感器数据与当前维护的子图进行匹配，寻找一个位姿估计使得传感器数据能够尽可能的与地图匹配上。调用 <strong>InsertIntoSubmap</strong> 将传感器数据插入到当前正在维护的子图中了。</p>
<p>前端更新了一次子图，会将一次激光扫描数据插入到维护的子图中，插入后的结果被认为为一<strong>轨迹上的节点</strong>，此时机器人位姿（理解为此次激光扫描的参考位姿）作为此节点位姿，称为<strong>扫描位姿（Scan Pose）</strong></p>
<h4 id="ProbabilityGrid"><a href="#ProbabilityGrid" class="headerlink" title="ProbabilityGrid"></a>ProbabilityGrid</h4><p>为概率栅格，请注意，<strong>Probability</strong> 是指栅格<strong>被占用</strong>的概率，而 Correspondence Cost 则是栅格空闲的概率。</p>
<h5 id="父类-Grid2D"><a href="#父类-Grid2D" class="headerlink" title="父类 Grid2D"></a>父类 Grid2D</h5><p>ProbabilityGrid 派生自父类 Grid2D。Gird2D 中是以 uint16 <strong>存储空闲概率</strong>。</p>
<table>
<thead>
<tr>
<th>对象名称</th>
<th>对象类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>limits_</td>
<td>MapLimits</td>
<td>地图的范围</td>
</tr>
<tr>
<td>correspondence_cost_cells_</td>
<td>std::vector<uint16></td>
<td>记录各个栅格单元的<strong>空闲概率</strong> <em>pfree</em>，0表示对应栅格概率未知，[1, 32767]表示空闲概率，可以通过一对儿函数CorrespondenceCostToValue和ValueToCorrespondenceCost相互转换。                Cartographer通过查表的方式更新栅格单元的占用概率。</td>
</tr>
<tr>
<td>min_correspondence_cost_</td>
<td>float</td>
<td><em>pfree</em>的最小值</td>
</tr>
<tr>
<td>max_correspondence_cost_</td>
<td>float</td>
<td><em>pfree</em>的最大值</td>
</tr>
<tr>
<td>update_indices_</td>
<td>std::vector<int></td>
<td>记录更新过的栅格单元的存储索引。</td>
</tr>
<tr>
<td>known_cells_box_</td>
<td>Eigen::AlignedBox2i</td>
<td>一个用于记录哪些栅格单元中有值的数据结构</td>
</tr>
</tbody></table>
<h4 id="占用概率更新与查找表"><a href="#占用概率更新与查找表" class="headerlink" title="占用概率更新与查找表"></a>占用概率更新与查找表</h4><p>没有看懂… <a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=%E6%9F%A5%E6%89%BE%E8%A1%A8%E4%B8%8E%E5%8D%A0%E7%94%A8%E6%A0%85%E6%A0%BC%E6%9B%B4%E6%96%B0">ref</a></p>
<h4 id="连接前端和后端：GlobalTrajectoryBuilder"><a href="#连接前端和后端：GlobalTrajectoryBuilder" class="headerlink" title="连接前端和后端：GlobalTrajectoryBuilder"></a>连接前端和后端：GlobalTrajectoryBuilder</h4><p>在 map_builder 构建 trajectory_builders_ 时，代码通过调用 CreateGlobalTrajectoryBuilder2D 也构建了一个 GlobalTrajectoryBuilder。实际完成局部建图任务的是一个 LocalTrajectoryBuilder2D 类型的对象，其并不具备任何闭环检测的能力，只是在不断的进行<strong>扫描匹配和子图更新</strong>。<strong>前后端之间一定存在某种通信</strong>使得后端能够看到前端所构建的子图和定位信息，进而达到<strong>闭环检测和全局优化</strong>的目的。这一工作被封装在了一个 GlobalTrajectoryBuilder 类型的对象中。</p>
<p>其是继承 TrajectoryBuilderInterface。</p>
<table>
<thead>
<tr>
<th>对象名称</th>
<th>对象类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>trajectory_id_</td>
<td>int</td>
<td>轨迹索引</td>
</tr>
<tr>
<td>pose_graph_</td>
<td>PoseGraph</td>
<td>位姿图，<strong>后端的核心对象</strong>，其数据类型是一个模板参数，我们的demo中实际使用的是 PoseGraph2D。</td>
</tr>
<tr>
<td>local_trajectory_builder_</td>
<td>LocalTrajectoryBuilder</td>
<td>位姿跟踪器，<strong>前端的核心对象</strong>，其数据类型是一个模板参数，我们的demo中实际使用的是LocalTrajectoryBuilder2D。</td>
</tr>
<tr>
<td>local_slam_result_callback_</td>
<td>LocalSlamResultCallback</td>
<td>前端数据更新后的回调函数。</td>
</tr>
</tbody></table>
<p>此接口，我们可以获得一个完整的SLAM技术栈，包括局部建图方法、局部位姿估计、闭环检测方法、以及面向稀疏位姿图的全局优化方法。</p>
<p><strong>InsertionResult</strong> 子图更新的结果（没有看懂 <a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=%E8%BF%9E%E6%8E%A5%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E6%A1%A5%E6%A2%81_GlobalTrajectoryBuilder">ref</a>）</p>
<h5 id="处理点云数据：AddSensorData"><a href="#处理点云数据：AddSensorData" class="headerlink" title="处理点云数据：AddSensorData"></a>处理点云数据：AddSensorData</h5><p>先对数据进行预处理后，将数据通过调用 Local SLAM 的 AddRangeData，来进行扫描匹配。前端完成后，再将前端的输出结果喂给后端进行闭环检测和全局优化。</p>
<h4 id="后端核心：PoseGraph2D"><a href="#后端核心：PoseGraph2D" class="headerlink" title="后端核心：PoseGraph2D"></a>后端核心：PoseGraph2D</h4><p>后端核心内容：</p>
<blockquote>
<p>大体上可以分为三个部分。其一接收来自Local SLAM的子图更新结果，在<strong>位姿图（PoseGraph）中相应的增加节点和约束</strong>，这点我们已经在<a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=%E8%BF%9E%E6%8E%A5%E5%89%8D%E7%AB%AF%E4%B8%8E%E5%90%8E%E7%AB%AF%E7%9A%84%E6%A1%A5%E6%A2%81_GlobalTrajectoryBuilder">连接前端与后端的桥梁</a>一文中有了初步的了解。其二结合里程计、IMU、全局位姿测量数据(Fixed Frame Pose, 类似GPS这样具有全局测量能力的传感器)的测量信息，使用[SPA(Sparse Pose Adjustment)](<a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu//papers/2010">http://gaoyichao.com/Xiaotu//papers/2010</a> - Efficient Sparse Pose Adjustment for 2D Mapping - Konolige et al.pdf)技术求解后端的<strong>优化问题</strong>。其三，在每次完成后端优化之后，都需要根据优化的结果对后来添加到位姿图中的节点和子图的位姿做<strong>修正</strong>。</p>
</blockquote>
<blockquote>
<p>   后端优化就是估计轨迹节点与子图在世界坐标系下的位姿，最小化全局估计与局部估计之间的偏差。</p>
</blockquote>
<h4 id="位姿图"><a href="#位姿图" class="headerlink" title="位姿图"></a>位姿图</h4><p>位姿图内包含若干个节点和子图，一个节点可能与多个子图存在关系。节点和子图之间的匹配关系是一种<strong>约束（Constraint）</strong>。请注意，节点之间也是有关系的，毕竟是通过里程计、IMU 等来计算出来，再加上前端的扫描匹配，每个节点之间也会有位置上的相对关系。</p>
<p>节点与子图之间的约束（Constraint），用如下结构体表示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Constraint</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Pose</span> &#123;</span><br><span class="line">        transform::Rigid3d zbar_ij;<span class="comment">//表示第i个子图与第j个节点之间的相对位姿</span></span><br><span class="line">        <span class="type">double</span> translation_weight;<span class="comment">//平移权重（描述不确定度）</span></span><br><span class="line">        <span class="type">double</span> rotation_weight;<span class="comment">//旋转权重（描述不确定度）</span></span><br><span class="line">    &#125;;</span><br><span class="line">    SubmapId submap_id;<span class="comment">//约束对应的子图索引</span></span><br><span class="line">    NodeId node_id;<span class="comment">//约束对应的节点索引</span></span><br><span class="line">    Pose pose;</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Tag</span> &#123; INTRA_SUBMAP, INTER_SUBMAP &#125; tag;<span class="comment">//子图内/间约束（前者指在子图的更新过程中节点j被直接插入到子图i中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子图的状态主要是给后台的线程提供的。一开始子图的状态都是kActive的，当它切换到kFinished的状态下后就会与所有的节点进行一次扫描匹配操作。此外新增的节点也会与所有kFinished状态的子图进行扫描匹配。这一操作我们可以理解为是进行闭环检测，通过遍历与所有的kFinished状态的子图，或者节点，应当可以找到发生闭环的地点并建立一个约束来描述。</p>
<h5 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h5><p>在 GlobalTrajectoryBuilder 作为前后端连接，添加点云数据 AddSensorData 时，在完成Local SLAM ，会调用 AddNode 将更新结果喂给后端。在后端，会构建一 TrajectoryNode 对象来作为新的节点，并放入相对应容器中。之后会再维护一下子图的容器（没有看懂）。最后为新节点添加<strong>约束任务 ComputeConstraintsForNode</strong>。在该任务下应当会将新增的节点与所有已经处于kFinished状态的子图进行一次<strong>匹配建立可能存在的闭环约束</strong>。此外，当有新的子图进入kFinished状态时，还会<strong>将之与所有的节点进行一次匹配</strong>。</p>
<h5 id="添加约束"><a href="#添加约束" class="headerlink" title="添加约束"></a>添加约束</h5><p>ComputeConstraintsForNode 可以添加约束且触发工作队列的构建与运行。不懂 <a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=%E4%BD%8D%E5%A7%BF%E5%9B%BE%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E6%9B%B4%E6%96%B0">ref</a></p>
<h4 id="constraint-builder"><a href="#constraint-builder" class="headerlink" title="constraint_builder_"></a>constraint_builder_</h4><p>不懂 <a target="_blank" rel="noopener" href="http://gaoyichao.com/Xiaotu/?book=Cartographer%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB&title=%E7%BA%A6%E6%9D%9F%E6%9E%84%E5%BB%BA%E5%99%A8_constraint_builder_">ref</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://aaairfox.github.io">Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://aaairfox.github.io/Cartographer%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/">https://aaairfox.github.io/Cartographer%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://aaairfox.github.io" target="_blank">AAAirFox</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SLAM/">SLAM</a><a class="post-meta__tags" href="/tags/cartographer/">cartographer</a></div><div class="post_share"><div class="social-share" data-image="/self/img/cover/carto.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Markdown%E8%AF%AD%E6%B3%95Demo/" title="Markdown语法Demo"><img class="cover" src="/self/img/cover/markdown.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Markdown语法Demo</div></div></a></div><div class="next-post pull-right"><a href="/%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%E6%B1%87%E6%80%BB_Hukuyo+%E4%B8%89%E7%A7%8D%E6%BF%80%E5%85%89slam%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="网址收藏汇总_Hukuyo+三种激光slam算法实现"><img class="cover" src="/self/img/cover/slam.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">网址收藏汇总_Hukuyo+三种激光slam算法实现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Hector_slam&Gmapping&Cartographer+Hokuyo%E5%BB%BA%E5%9B%BE/" title="Hector_slam&amp;Gmapping&amp;Cartographer+Hokuyo建图"><img class="cover" src="/self/img/cover/Hector_slam&Gmapping&Carto.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-16</div><div class="title">Hector_slam&amp;Gmapping&amp;Cartographer+Hokuyo建图</div></div></a></div><div><a href="/cartographer%E5%AE%89%E8%A3%85/" title="cartographer安装"><img class="cover" src="/self/img/cover/carto.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-03-16</div><div class="title">cartographer安装</div></div></a></div><div><a href="/%E7%BD%91%E5%9D%80%E6%94%B6%E8%97%8F%E6%B1%87%E6%80%BB_Hukuyo+%E4%B8%89%E7%A7%8D%E6%BF%80%E5%85%89slam%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" title="网址收藏汇总_Hukuyo+三种激光slam算法实现"><img class="cover" src="/self/img/cover/slam.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-23</div><div class="title">网址收藏汇总_Hukuyo+三种激光slam算法实现</div></div></a></div><div><a href="/Chapter1-%E6%BF%80%E5%85%89SLAM%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D/" title="Chapter1-激光SLAM简要介绍"><img class="cover" src="/self/img/cover/%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-01</div><div class="title">Chapter1-激光SLAM简要介绍</div></div></a></div><div><a href="/Chapter2-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86I%EF%BC%9A%E9%87%8C%E7%A8%8B%E8%AE%A1%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E5%8F%8A%E6%A0%87%E5%AE%9A/" title="Chapter2-传感器数据处理I：里程计运动模型及标定"><img class="cover" src="/self/img/cover/%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-01</div><div class="title">Chapter2-传感器数据处理I：里程计运动模型及标定</div></div></a></div><div><a href="/Chapter3-%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86II%EF%BC%9A%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%92%8C%E8%BF%90%E5%8A%A8%E7%95%B8%E5%8F%98%E5%8E%BB%E9%99%A4/" title="Chapter3-传感器数据处理II：激光雷达数学模型和运动畸变去除"><img class="cover" src="/self/img/cover/%E6%B7%B1%E8%93%9D%E5%AD%A6%E9%99%A2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-07-01</div><div class="title">Chapter3-传感器数据处理II：激光雷达数学模型和运动畸变去除</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Zhang</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">77</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">25</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Cartographer-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">Cartographer 源码阅读总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E5%8F%A3%EF%BC%9Acartographer-node"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">入口：cartographer_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ROS-%E4%B8%BB%E9%A2%98%E7%9A%84%E8%AE%A2%E9%98%85%EF%BC%8C%E5%85%A5%E5%8F%A3%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9Anode"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">ROS 主题的订阅，入口的核心：node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9Amap-builder-bridge"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">数据的转换：map_builder_bridge_</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86-ROS-%E4%BF%A1%E6%81%AF%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%B8%E5%BF%83%E7%AE%97%E6%B3%95%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%EF%BC%9ASensorBridge"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">将 ROS 信息转换为核心算法传感器数据：SensorBridge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9B%BE%EF%BC%9Amap-builder"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">地图：map_builder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-builder-%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.0.6.</span> <span class="toc-text">map_builder 的接口实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E6%A0%B8%E5%BF%83%EF%BC%9ALocalTrajectoryBuilder2D"><span class="toc-number">1.0.0.7.</span> <span class="toc-text">前端核心：LocalTrajectoryBuilder2D</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AddRangeData%EF%BC%9A%E5%9F%BA%E6%9C%AC%E4%B8%8A%E5%AE%8C%E6%88%90%E4%BA%86%E6%95%B4%E4%B8%AALocal-SLAM%E7%9A%84%E4%B8%9A%E5%8A%A1%E3%80%82"><span class="toc-number">1.0.0.7.1.</span> <span class="toc-text">AddRangeData：基本上完成了整个Local SLAM的业务。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#AddAccumulatedRangeData%EF%BC%9A%E7%A7%AF%E7%B4%AF%E4%BC%A0%E6%84%9F%E5%99%A8%E6%95%B0%E6%8D%AE%E4%B8%80%E5%AE%9A%E9%87%8F%E5%90%8E%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%8C%E4%BB%A5%E6%89%AB%E6%8F%8F%E5%8C%B9%E9%85%8D%E3%80%81%E6%9B%B4%E6%96%B0%E5%AD%90%E5%9B%BE"><span class="toc-number">1.0.0.7.2.</span> <span class="toc-text">AddAccumulatedRangeData：积累传感器数据一定量后被调用，以扫描匹配、更新子图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ProbabilityGrid"><span class="toc-number">1.0.0.8.</span> <span class="toc-text">ProbabilityGrid</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB-Grid2D"><span class="toc-number">1.0.0.8.1.</span> <span class="toc-text">父类 Grid2D</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%A0%E7%94%A8%E6%A6%82%E7%8E%87%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%9F%A5%E6%89%BE%E8%A1%A8"><span class="toc-number">1.0.0.9.</span> <span class="toc-text">占用概率更新与查找表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF%EF%BC%9AGlobalTrajectoryBuilder"><span class="toc-number">1.0.0.10.</span> <span class="toc-text">连接前端和后端：GlobalTrajectoryBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%EF%BC%9AAddSensorData"><span class="toc-number">1.0.0.10.1.</span> <span class="toc-text">处理点云数据：AddSensorData</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF%E6%A0%B8%E5%BF%83%EF%BC%9APoseGraph2D"><span class="toc-number">1.0.0.11.</span> <span class="toc-text">后端核心：PoseGraph2D</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%A7%BF%E5%9B%BE"><span class="toc-number">1.0.0.12.</span> <span class="toc-text">位姿图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="toc-number">1.0.0.12.1.</span> <span class="toc-text">添加节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%BA%A6%E6%9D%9F"><span class="toc-number">1.0.0.12.2.</span> <span class="toc-text">添加约束</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constraint-builder"><span class="toc-number">1.0.0.13.</span> <span class="toc-text">constraint_builder_</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%8E%A8%E6%B5%81%E6%96%B9%E6%A1%88/" title="目标检测推流方案"><img src="/self/img/cover/detect.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="目标检测推流方案"/></a><div class="content"><a class="title" href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E6%8E%A8%E6%B5%81%E6%96%B9%E6%A1%88/" title="目标检测推流方案">目标检测推流方案</a><time datetime="2024-04-13T08:23:15.000Z" title="发表于 2024-04-13 16:23:15">2024-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9F%BA%E7%A1%80/" title="目标检测基础"><img src="/self/img/cover/detect.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="目标检测基础"/></a><div class="content"><a class="title" href="/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%E5%9F%BA%E7%A1%80/" title="目标检测基础">目标检测基础</a><time datetime="2024-04-13T08:23:15.000Z" title="发表于 2024-04-13 16:23:15">2024-04-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95/" title="综合面试"><img src="/self/img/cover/cover-2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="综合面试"/></a><div class="content"><a class="title" href="/%E7%BB%BC%E5%90%88%E9%9D%A2%E8%AF%95/" title="综合面试">综合面试</a><time datetime="2024-04-11T02:38:50.000Z" title="发表于 2024-04-11 10:38:50">2024-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BA%A4%E4%BB%98/" title="项目之测试与交付"><img src="/self/img/cover/management.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目之测试与交付"/></a><div class="content"><a class="title" href="/%E9%A1%B9%E7%9B%AE%E4%B9%8B%E6%B5%8B%E8%AF%95%E4%B8%8E%E4%BA%A4%E4%BB%98/" title="项目之测试与交付">项目之测试与交付</a><time datetime="2024-04-10T06:52:55.000Z" title="发表于 2024-04-10 14:52:55">2024-04-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/C%E5%8D%8F%E7%A8%8B/" title="C++协程"><img src="/self/img/cover/c.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++协程"/></a><div class="content"><a class="title" href="/C%E5%8D%8F%E7%A8%8B/" title="C++协程">C++协程</a><time datetime="2024-04-09T11:28:42.000Z" title="发表于 2024-04-09 19:28:42">2024-04-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By Zhang</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hello World!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>